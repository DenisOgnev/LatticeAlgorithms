\newpage

\section{Нахождение ЭНФ (TODO)}

Для нахождения ЭНФ будет разобрано два алгоритма - для матриц с полным рангом строки и общий (для любых матриц), который сводится к использованию первого алгоритма. Оба алогритма предполагают использование ортогонализации Грама-Шмидта, поэтому предварительно будет дано его описание.

\subsection{Ортогонализация Грама-Шмидта}

Любой базис $ \mathbf{B} $ может быть преобразован в ортогональный базис для того же векторного пространства используя алгоритм ортогонализации Грама-Шмидта.
Предположим у нас есть набор векторов $ \mathbf{B} = [\mathbf{b}_1, \ldots, \mathbf{b}_n] $, $ \mathbf{B} \in \mathbb{R}^{m \times n} $. Этот набор необзятельно ортогонален или даже линейно независим. Ортогонализацией этого набора векторов является набор векторов $ \mathbf{B}^* = [\mathbf{b}^*_1, \cdots, \mathbf{b}^*_n] \in \mathbb{R}^{m \times n} $, где $$ \mathbf{b}^*_i = \mathbf{b}_i - \sum_{i < j} \mu_{i, j} \mathbf{b}^*_j, \text{ где } \mu_{i, j} = \frac{\left\langle \mathbf{b}_i, \mathbf{b}^*_j \right\rangle}{\left\langle \mathbf{b}^*_i, \mathbf{b}^*_j \right\rangle}, i = 1, \ldots, n, j = 1, \ldots, i $$

Полученный набор векторов может не являться базисом для решетки, сгенерированной от исходного набора векторов, т.к. точки этой решетки могут не входить в решетку от ортогонализованного базиса. Этот набор также обладает важным свойством, которое мы будем использовать: если вектор $ \mathbf{b}^*_i = \mathbf{0} $, то этот вектор линейно зависим от других векторов в наборе и может быть представлен линейной комбинацией этих векторов. 

\subsection{Алгоритм для матриц с полным рангом строки}

Дана матрица $ \mathbf{B} \in \mathbb{Z}^{m \times n} $. Основная идея состоит в том, чтобы найти ЭНФ $ \mathbf{H} $ подрешетки от $ \mathcal{L}(\mathbf{B}) $, и затем обновлять $ \mathbf{H} $, включая столбцы $ \mathbf{B} $ один за другим. Предположим, что у нас есть процедура AddColumn, которая работает за полиномиальное время и принимает на вход квадратную невырожденную ЭНФ матрицу $ \mathbf{H} \in \mathbb{Z}^{m \times m} $ и вектор $ \mathbf{b} \in \mathbb{Z}^{m}$, а возвращает ЭНФ матрицы $ [\mathbf{H|b}] $. Такая процедура должна следить, чтоб выходная матрица подоходила под определение ЭНФ, что будет показано в описании этой процедуры. ЭНФ от $ \mathbf{B} $ может быть вычислено следующим образом:
\begin{enumerate}
\item Применить алгоритм Грама-Шмидта к столбцам $ \mathbf{B} $, чтобы найти $ m $ линейно независимых столбцов. Пусть $ \mathbf{B}' $ - матрица размера $ m \times m $, заданная этими столбцами.
\item Вычислить $ d=\mathrm{det}(\mathbf{B}') $, используя алгоритм Грама-Шмидта или любую другую процедуру с полиномиальным временем. Пусть $ \mathbf{H}_0=d \cdot \mathbf{I} $ будет диагональной матрицей с $ d $ на диагонали.
\item Для $ i=1, \ldots ,n $ пусть $ \mathbf{H}_i $ -- результат применения AddColumn к входным $  \mathbf{H}_{i-1}\ $ и $ \mathbf{b}_i $.
\item Вернуть $ \mathbf{H}_n $.
\end{enumerate}

Разберем подпункты:

\begin{enumerate}
\item Необходимо найти линейно независимые столбцы матрицы. Их количество всегда будет равно $ m $, т.к. наша матрица полного ранга строки и ранг матрицы равен $ m $, а значит матрица, состоящая из этих столбцов, будет размера $ m \times m $. Для нахождения этих строк можно использовать алгоритм ортогонализации Грама-Шмитда: если $ \mathbf{b}_i^*=\mathbf{0} $, то $ i $-ая строка является линейной комбинацией других строк, и ее необходимо удалить. Реализация данного алгоритма находится в пространстве имен Utils в функции \verb! get_linearly_independent_!\\ \verb!columns_by_gram_schmidt!. Полученная матрица будет названа $  \mathbf{B}' $.
\item Необходимо вычислить $ d $, будем вычислять его по следующей форумле: $ d=\sqrt{\prod_i{\|\mathbf{b}_i^\ast\|^2}} $ - сумма произведений квадратов длин всех столбцов, полученных после применения ортогонализации Грама-Шмидта. Матрица $ \mathbf{H}_\mathbf{0} $ будет единичной матрицей размера $ m \times m $, умноженной на определитель. В результате все диагональные элементы будут равны $ d $.
\item Применяем AddColumn (реализация находится в функции \verb!add_column!) к $ \mathbf{H}_0 $ и первому столбцу матрицы $ \mathbf{B} - \mathbf{b}_0 $, получаем $ \mathbf{H}_1 $; повторяем для всех оставшихся столбцов, получаем $ \mathbf{H}_n $.
\item $ \mathbf{H}_n $ является ЭНФ($ \mathbf{B} $).
\end{enumerate}

Алгоритм AddColumn на вход принимает квадратную невырожденную ЭНФ матрицы $ \mathbf{H} \in \mathbb{Z}^{m \times m} $ и вектор $ \mathbf{b} \in \mathbb{Z}^m $ и работает следующим образом. Если $ m = 0 $, то возвращаем $ \mathbf{H} $. В противном случае, пусть 
$ \mathbf{H} = \left[ \begin{array}{cccc}
\mathrm{a} & \mathbf{0}^\mathrm{T} \\
\mathbf{h} & \mathbf{H}' \end{array} \right] $ и 
$ \mathbf{b} = \left[ \begin{array}{cccc}
\mathrm{b} \\
\mathbf{b}' \end{array} \right] $ и дальше:

\begin{enumerate}
\item Вычислить $ \mathrm{g}=\text{НОД}⁡(\mathrm{a, b}) $ и целые $ \mathrm{x, y} $ такие, что $ \mathrm{xa+yb=g} $, используя расширенный НОД алгоритм.
\item Применить унимодулярное преобразование 
$ \mathbf{U}=\left[ \begin{array}{cccc}
\mathrm{x} & \mathrm{(\text{-}b/g)} \\ 
\mathrm{y} & \mathrm{(a/g)} \end{array} \right] $ к первому столбцу из $ \mathbf{H} $ и $ \mathbf{b} $ чтобы получить 
$ \left[ \begin{array}{cccc}
\mathrm{a} & \mathrm{b} \\
\mathbf{h} & \mathbf{b}' \end{array} \right] \mathbf{U}=
\left[ \begin{array}{cccc}
\mathrm{g} & \mathrm{0} \\
\mathbf{h}' & \mathbf{b}'' \end{array} \right] $ 
\item Добавить соответствующий вектор из $ \mathcal{L}\left(\mathbf{H}'\right) $ к $ \mathbf{b}'' $, чтобы сократить его элементы по модулю диагональных элементов из $ \mathbf{H}' $.
\item Рекурсивно вызвать AddColumn на вход $ \mathbf{H}' $ и $ \mathbf{b}'' $ чтобы получить матрицу $ \mathbf{H}'' $.
\item Добавить соответствующий вектор из $ \mathcal{L}\left(\mathbf{H}''\right) $ к $ \mathbf{h}' $ чтобы сократить его элементы по модулю диагональных элементов из $ \mathbf{H}'' $.
\item Вернуть $ \left[\begin{array}{cccc}
\mathrm{g} & \mathbf{0}^\mathrm{T} \\
\mathbf{h}' & \mathbf{H}'' 
\end{array}\right] $ 

\end{enumerate}

Разберем подпункты:

\begin{enumerate}
\item Функция extended\_gcd принимает $ \mathrm{a, b} $ , вычисляет наибольший общий делитель и целые $ \mathrm{x, y} $ такие, что $ \mathrm{xa + yb = g} $
\item Составляем матрицу $ \mathbf{U}= \left[\begin{array}{cccc}
\mathrm{x} & \mathrm{(\text{-}b/g)} \\
\mathrm{y} & \mathrm{(a/g)} \end{array}\right] $ и умножаем ее на матрицу, составленную из первого столбца $ \mathbf{H} $ и столбца $ \mathbf{b} $, чтобы получить
$$ \left[\begin{array}{cccc}
\mathrm{a} & \mathrm{b} \\
\mathbf{h} & \mathbf{b}' \end{array}\right] \mathbf{U}=
\left[\begin{array}{cccc}
\mathrm{g} & \mathrm{0} \\
\mathbf{h}' & \mathbf{b}'' \end{array}\right] $$
\item Функция \verb!reduce! принимает на вход матрицу и вектор, получает необходимый вектор из решетки от матрицы на входе, чтобы сократить элементы вектора по модулю диагональных элементов из матрицы. Применяем функцию \verb!reduce! к $ \mathbf{H}' $ и $ \mathbf{b} $
\item Рекурсивно вызываем AddColumn, на вход отправляем $ \mathbf{H}' $ и $ \mathbf{b}'' $  получаем матрицу $ \mathbf{H}'' $.
\item Вызываем функцию \verb!reduce! к $ \mathbf{H}'' $ и $ \mathbf{h}' $
\item Составляем необходимую матрицу и возвращаем $ \left[\begin{array}{cccc}
\mathrm{g} & \mathbf{0}^\mathrm{T} \\
\mathbf{h}' & \mathbf{H}'' \end{array}\right] $
\end{enumerate}

\subsection{Общий алгоритм для любых матриц}

\begin{enumerate}
\item Запустить процесс ортогонализации Грама-Шмидта к строкам $ \mathbf{r}_1, \ldots, \mathbf{r}_m $ из $ \mathbf{B} $, и пусть $ \mathrm{K}=\left\{\mathrm{k}_1, \ldots, \mathrm{k}_l \right\}(\mathrm{k}_1< \ldots <\mathrm{k}_l) $ – это множество индексов, такое, что $ \mathbf{r}_{\mathrm{k}_i}^\ast \neq \mathbf{0} $. Определим операцию проецирования $ \prod_\mathrm{K}:\mathbb{R}^m \rightarrow \mathbb{R}^l $ при $ [\prod_\mathrm{K}(\mathbf{x})]_i = \mathrm{x}_{\mathrm{k}_i} $. Заметим, что строки $ \mathbf{r}_\mathrm{k}\ (\mathrm{k} \in \mathrm{K}) $ линейно независимы и любая строка $ \mathbf{r}_i\ (i \in \mathrm{K}) $ может быть выражена как линейная комбинация предыдущих строк $ \mathbf{r}_j\left(\left\{j \in \mathrm{K}:j<i \right\}\right) $. Следовательно, операция проецирования $ \prod_\mathrm{K} $ однозначно определена, когда ограничена к $ \mathcal{L}(\mathbf{B})$ , и ее инверсия может быть легко вычислена, используя коэффициенты Грама-Шмидта $ \mu_{i,j} $.
\item Введем матрицу $ \mathbf{B}'=\prod_\mathrm{K}(\mathbf{B}) $, которая полного ранга (т.к. все строки линейно независимы), и запустим алгоритм для матриц полного ранга строки, чтобы найти ЭНФ $ \mathbf{B}'' $ от $ \mathbf{B}' $.
\item Применить функцию, обратную операции проецирования, $ \prod_\mathrm{K}^{\text{-}1} $ к ЭНФ $ \mathbf{B}'' $, чтобы получить матрицу $ \mathbf{H} $, которая является ЭНФ матрицы $ \mathbf{B} $.
\end{enumerate}

Алгоритм прост, но нужно обратить внимание на операцию проецирования и обратную к ней. Для того, чтобы находить результат проецирования напишем функцию \verb! get_linearly_! \\ \verb!independent_rows_by_gram_schmidt!, которая будет возвращать матрицу $ \mathbf{B}' $, состоящую из линейно независимых строк, а также массив индексов этих строк из исходного массива. К матрице $ \mathbf{B}' $ применяется алгоритм нахождения ЭНФ для матриц с полным рангом, разобранный в прошлом разделе. Далее необходимо восстановить удаленные строки. Т.к. они являются линейной комбинацией линейно независимых строк, то мы можем найти коэффициенты, на которые нужно умножить строки из матрицы $ \mathbf{B}' $ и после чего сложить их, чтобы получить нужную строку, которую необходимо добавить к $ \mathbf{B}' $.

\subsection{Пример нахождения ЭНФ}

Рассмотрим нахождение ЭНФ на примере небольшой матрицы размера $ 2 \times 2 $. Получим случайную матрицу $ \mathbf{B} =
\left[ \begin{array}{cccc}
\mathbf{b}^{\mathbf{T}}_1 \\
\vdots \\
\mathbf{b}^{\mathbf{T}}_m
\end{array} \right]
=
\left[ \begin{array}{cccc}
2 & 4 \\
1 & 4
\end{array} \right] $. Т.к. мы получаем случайную матрицу, то не можем заранее знать, матрица с полного ранга строки или нет, поэтому будем использовать общий алгоритм. Первый шаг алгоритма требует от нас найти $ l $ линейно независимых строк матрицы $ \mathbf{B} $, используя алгоритм ортогонализации Грама-Шмидта. Обозначим искомую ортогонализацию строк за $ \mathbf{B}^* = \left[ \begin{array}{cccc}
\mathbf{b}^{\mathbf{T}*}_1 \\
\vdots \\
\mathbf{b}^{\mathbf{T}*}_m
\end{array} \right] $ и найдем их:

\begin{enumerate}

\item $ \mathbf{b}^{\mathbf{T}*}_1 = \mathbf{b}^{\mathbf{T}}_1 + \sum\limits_{j < 1} \mu_{1, j}\mathbf{b}^{\mathbf{T}*}_j = \mathbf{b}^{\mathbf{T}}_1 = \left[ \begin{array}{cccc}
2 & 4
\end{array}
\right]$

\item $ \mathbf{b}^{\mathbf{T}*}_2 = \mathbf{b}^{\mathbf{T}}_2 + \sum\limits_{j < 2} \mu_{2, j}\mathbf{b}^{\mathbf{T}*}_j = \mathbf{b}^{\mathbf{T}}_2 + \frac{\left\langle \mathbf{b}^{\mathbf{T}}_2, \mathbf{b}^{\mathbf{T}*}_1 \right\rangle}{\left\langle \mathbf{b}^{\mathbf{T}*}_1, \mathbf{b}^{\mathbf{T}*}_1 \right\rangle} \mathbf{b}^{\mathbf{T}*}_1 = \left[ \begin{array}{cccc}
-\frac{4}{5} & \frac{2}{5}
\end{array}
\right]$

\end{enumerate}

Нулевых строк нет, значит матрица $ \mathbf{B} $ полностью состоит из линейно независимых строк, и матрица $ \mathbf{B}' $ будет содержать в себе все строки из $ \mathbf{B} $. Далее алгоритм требует от нас найти ЭНФ от матрицы $ \mathbf{B}' $, используя алгоритм для полного ранга строки.

Рассмотрим алгоритм для полного ранга строки. Алгоритм принимает на вход матрицу $ \mathbf{B} = \left[ \mathbf{b}_1, \ldots, \mathbf{b}_n \right] =
\left[ \begin{array}{cccc}
2 & 4 \\
1 & 4
\end{array} \right] $. Требуется найти $ m $ линейно независимых строк, используя алгоритм Грама-Шмидта. Используем алгоритм Грама-Шмидта на строки $ \mathbf{B} $:

\begin{enumerate}

\item $ \mathbf{b}^*_1 = \mathbf{b}_1 + \sum\limits_{j < 1} \mu_{1, j}\mathbf{b}^*_j = \mathbf{b}_1 = \left[ \begin{array}{cccc}
2 \\ 
1 
\end{array}
\right]$

\item $ \mathbf{b}^*_2 = \mathbf{b}^{\mathbf{T}}_2 + \sum\limits_{j < 2} \mu_{2, j}\mathbf{b}^*_j = \mathbf{b}_2 + \frac{\left\langle \mathbf{b}_2, \mathbf{b}^*_1 \right\rangle}{\left\langle \mathbf{b}^*_1, \mathbf{b}^*_1 \right\rangle} \mathbf{b}^*_1 = \left[ \begin{array}{cccc}
-\frac{4}{5} \\
\frac{8}{5}
\end{array}
\right]$

\end{enumerate}

Т.к. матрица полного ранга строки, ее ранг меньше либо равен количеству столбцов и равен количеству строк $ m $. Используя алгоритм Грама-Шмидта на столбцы матрицы мы удаляем линейно зависимые столбцы, и т.к. количество столбцов больше либо равно количества строк, то количество столбцов становится равно количеству строк. Получаем матрицу $ \mathbf{B}' = \left[\begin{array}{cccc}
2 & 4 \\
1 & 4
\end{array}\right] $ размера $ m \times m $, состоящую из линейно независимых столбцов матрицы $ \mathbf{B} $.

Далее необходимо составить матрицу $ \mathbf{H}_0 $. Для этого необходимо найти определитель решетки $ d = \sqrt{(5 \cdot \frac{16}{5})} = 4 $ и умножить единичную матрицу размера $ m \times m $ на $ d $. 

Для $ i = 1, \ldots, n $ используем AddColumn для каждого $ \mathbf{H}_{i - 1} $ и $ \mathbf{b}_i $:
\begin{enumerate}

\item $ \mathbf{H} = \left[\begin{array}{cccc}
4 & 0 \\
0 & 4
\end{array}\right] $, $ \mathrm{a} = 4 $, $ \mathbf{h} = \left[\begin{array}{cccc}
0 
\end{array}\right] $, $ \mathbf{H}' = \left[ \begin{array}{cccc}
4
\end{array}\right] $, $ \mathbf{b} = \left[\begin{array}{cccc}
2 \\
1
\end{array}\right] $, $ \mathrm{b} = 2 $, $ \mathbf{b}' = \left[ \begin{array}{cccc}
1
\end{array}\right] $

Используем расширенный НОД алгоритм, находим $ \mathrm{g} = 2 $, $ \mathrm{x} = 0 $, $ \mathrm{y} = 1 $. Составляем матрицу $  \mathbf{U} = \left[\begin{array}{cccc}
0 & -1 \\
1 & 2
\end{array}\right] $, умножаем матрицу, составленную из первого столбца $ \mathbf{H} $ и столбца $ \mathbf{b} $ на матрицу $ \mathbf{U} $: $ \left[ \begin{array}{cccc}
\mathrm{a} & \mathrm{b} \\
\mathbf{h} & \mathbf{b}' \end{array} \right] \mathbf{U}=
\left[ \begin{array}{cccc}
\mathrm{g} & \mathrm{0} \\
\mathbf{h}' & \mathbf{b}'' \end{array} \right] = \left[\begin{array}{cccc}
2 & 0 \\
1 & 2
\end{array}\right] $, $ \mathbf{h}' = \left[\begin{array}{cccc}
1
\end{array}\right] $, $ \mathbf{b}'' = \left[\begin{array}{cccc}
2
\end{array}\right] $

Сокращаем $ \mathbf{b}'' $ по модулю диагональных элементов из $ \mathbf{H}' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}') $: $ \mathbf{b}'' = \left[ \begin{array}{cccc}
2
\end{array}\right] $.

Рекурсивно вызываем AddColumn со входом $ \mathbf{H}' $ и $ \mathbf{b}'' $, получаем матрицу $ \mathbf{H}'' = \left[\begin{array}{cccc}
2
\end{array}\right] $:
\begin{itemize}
\item $ \mathbf{H} = \left[\begin{array}{cccc}
4
\end{array}\right] $, $ \mathrm{a} = 4 $, $ \mathbf{h} = \left[\begin{array}{cccc}
\end{array}\right] $, $ \mathbf{H}' = \left[ \begin{array}{cccc}
\end{array}\right] $, $ \mathbf{b} = \left[\begin{array}{cccc}
2
\end{array}\right] $, $ \mathrm{b} = 2 $, $ \mathbf{b}' = \left[ \begin{array}{cccc}
\end{array}\right] $

Находим $ \mathrm{g} = 2 $, $ \mathrm{x} = 0 $, $ \mathrm{y} = 1 $. Составляем матрицу $  \mathbf{U} = \left[\begin{array}{cccc}
0 & -1 \\
1 & 2
\end{array}\right] $, умножаем: $ \left[ \begin{array}{cccc}
\mathrm{a} & \mathrm{b} \\
\mathbf{h} & \mathbf{b}' \end{array} \right] \mathbf{U}=
\left[ \begin{array}{cccc}
\mathrm{g} & \mathrm{0} \\
\mathbf{h}' & \mathbf{b}'' \end{array} \right] = \left[\begin{array}{cccc}
2 & 0
\end{array}\right] $, $ \mathbf{h}' = \left[\begin{array}{cccc}
\end{array}\right] $, $ \mathbf{b}'' = \left[\begin{array}{cccc}
\end{array}\right] $

Сокращаем $ \mathbf{b}'' $ по модулю диагональных элементов из $ \mathbf{H}' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}') $: $ \mathbf{b}'' = \left[ \begin{array}{cccc}
\end{array}\right] $.

Рекурсивно вызываем AddColumn со входом $ \mathbf{H}' $ и $ \mathbf{b}'' $: произойдет выход из рекурсии по условию и вернется пустая матрица $ \mathbf{H}'' $.

Сокращаем $ \mathbf{h}' $ по модулю диагональных элементов из $ \mathbf{H}'' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}'') $: $ \mathbf{h}' = \left[ \begin{array}{cccc}
\end{array}\right] $.

Возвращаем $ \left[\begin{array}{cccc}
\mathrm{g} & \mathbf{0}^\mathbf{T} \\
\mathbf{h}' & \mathbf{H}''
\end{array}\right] = \left[\begin{array}{cccc}
2
\end{array}\right] $
\end{itemize}

Сокращаем $ \mathbf{h}' $ по модулю диагональных элементов из $ \mathbf{H}'' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}'') $: $ \mathbf{h}' = \left[ \begin{array}{cccc}
2
\end{array}\right] $.

Возвращаем $ \left[\begin{array}{cccc}
\mathrm{g} & \mathbf{0}^\mathbf{T} \\
\mathbf{h}' & \mathbf{H}''
\end{array}\right] = \left[\begin{array}{cccc}
2 & 0 \\
1 & 2
\end{array}\right] $

\item $ \mathbf{H} = \left[\begin{array}{cccc}
2 & 0 \\
1 & 2
\end{array}\right] $, $ \mathrm{a} = 2 $, $ \mathbf{h} = \left[\begin{array}{cccc}
1 
\end{array}\right] $, $ \mathbf{H}' = \left[ \begin{array}{cccc}
2
\end{array}\right] $, $ \mathbf{b} = \left[\begin{array}{cccc}
4 \\
4
\end{array}\right] $, $ \mathrm{b} = 4 $, $ \mathbf{b}' = \left[ \begin{array}{cccc}
4
\end{array}\right] $

Находим $ \mathrm{g} = 2 $, $ \mathrm{x} = 0 $, $ \mathrm{y} = 1 $. Составляем матрицу $  \mathbf{U} = \left[\begin{array}{cccc}
1 & -2 \\
0 & 1
\end{array}\right] $, умножаем: $ \left[ \begin{array}{cccc}
\mathrm{a} & \mathrm{b} \\
\mathbf{h} & \mathbf{b}' \end{array} \right] \mathbf{U}=
\left[ \begin{array}{cccc}
\mathrm{g} & \mathrm{0} \\
\mathbf{h}' & \mathbf{b}'' \end{array} \right] = \left[\begin{array}{cccc}
2 & 0 \\
1 & 2
\end{array}\right] $, $ \mathbf{h}' = \left[\begin{array}{cccc}
1
\end{array}\right] $, $ \mathbf{b}'' = \left[\begin{array}{cccc}
2
\end{array}\right] $

Сокращаем $ \mathbf{b}'' $ по модулю диагональных элементов из $ \mathbf{H}' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}') $: $ \mathbf{b}'' = \left[ \begin{array}{cccc}
0
\end{array}\right] $.

Рекурсивно вызываем AddColumn со входом $ \mathbf{H}' $ и $ \mathbf{b}'' $, получаем матрицу $ \mathbf{H}'' = \left[\begin{array}{cccc}
2
\end{array}\right] $:
\begin{itemize}
\item $ \mathbf{H} = \left[\begin{array}{cccc}
2
\end{array}\right] $, $ \mathrm{a} = 2 $, $ \mathbf{h} = \left[\begin{array}{cccc}
\end{array}\right] $, $ \mathbf{H}' = \left[ \begin{array}{cccc}
\end{array}\right] $, $ \mathbf{b} = \left[\begin{array}{cccc}
0
\end{array}\right] $, $ \mathrm{b} = 0 $, $ \mathbf{b}' = \left[ \begin{array}{cccc}
\end{array}\right] $

Находим $ \mathrm{g} = 2 $, $ \mathrm{x} = 1 $, $ \mathrm{y} = 0 $. Составляем матрицу $  \mathbf{U} = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $, умножаем: $ \left[ \begin{array}{cccc}
\mathrm{a} & \mathrm{b} \\
\mathbf{h} & \mathbf{b}' \end{array} \right] \mathbf{U}=
\left[ \begin{array}{cccc}
\mathrm{g} & \mathrm{0} \\
\mathbf{h}' & \mathbf{b}'' \end{array} \right] = \left[\begin{array}{cccc}
2 & 0
\end{array}\right] $, $ \mathbf{h}' = \left[\begin{array}{cccc}
\end{array}\right] $, $ \mathbf{b}'' = \left[\begin{array}{cccc}
\end{array}\right] $

Сокращаем $ \mathbf{b}'' $ по модулю диагональных элементов из $ \mathbf{H}' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}') $: $ \mathbf{b}'' = \left[ \begin{array}{cccc}
\end{array}\right] $.

Рекурсивно вызываем AddColumn со входом $ \mathbf{H}' $ и $ \mathbf{b}'' $: произойдет выход из рекурсии по условию и вернется пустая матрица $ \mathbf{H}'' $.

Сокращаем $ \mathbf{h}' $ по модулю диагональных элементов из $ \mathbf{H}'' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}'') $: $ \mathbf{h}' = \left[ \begin{array}{cccc}
\end{array}\right] $.

Возвращаем $ \left[\begin{array}{cccc}
\mathrm{g} & \mathbf{0}^\mathbf{T} \\
\mathbf{h}' & \mathbf{H}''
\end{array}\right] = \left[\begin{array}{cccc}
2
\end{array}\right] $
\end{itemize}

Сокращаем $ \mathbf{h}' $ по модулю диагональных элементов из $ \mathbf{H}'' $, вычисляя и добавляя соответствующий вектор из $ \mathcal{L}(\mathbf{H}'') $: $ \mathbf{h}' = \left[ \begin{array}{cccc}
2
\end{array}\right] $.

Возвращаем $ \left[\begin{array}{cccc}
\mathrm{g} & \mathbf{0}^\mathbf{T} \\
\mathbf{h}' & \mathbf{H}''
\end{array}\right] = \left[\begin{array}{cccc}
2 & 0 \\
1 & 2
\end{array}\right] $
\end{enumerate}

ЭНФ($ \mathbf{B} $) = $ \left[\begin{array}{cccc}
2 & 0 \\
1 & 2
\end{array}\right] $

\subsection{Сложность алгоритма}

\subsection{Обзор программной реализации}

Программная реализация тестировалась в режиме сборки Release на ПК со следующими характеристиками: CPU: Intel(R) Core (TM) i5-9600KF CPU @ 3.70GHz, ОЗУ: DDR4, 16 ГБ (двухканальных режим 8х2), 2666 МГц.

\begin{table}[h]
  \caption{Время работы ЭНФ}
  \centering
  \begin{tabular}{ | l | l | l |}
  \hline
  m & n & Время, сек   \\ \hline
  5 & 5 & 0.0008 \\ \hline
  10 & 10 & 0.002 \\ \hline
  25 & 25 & 0.88 \\ \hline
  50 & 50 & 1.61 \\ \hline
  75 & 75 & 8.4 \\ \hline
  100 & 100 & 27.17 \\ \hline
  200 & 100 & 62.35 \\ \hline
  100 & 200 & 79.18 \\ \hline
  \end{tabular}
  \label{table:HNF}
\end{table}

\subsection{Применение}

Будут рассмотрены некоторые проблемы и задачи теории решеток и их решение с помощью ЭНФ.

\textbf{Нахождение базиса.} Дан набор рациональных векторов $ \mathbf{B} $, необходимо вычислить базис для $ \mathcal{L}(\mathbf{B}) $. Проблема решается за полиномиальное время путем вычисления $ \text{ЭНФ}(\mathbf{B}) $: 

$ \mathbf{B} = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
2 & 0 \\
0 & 1
\end{array}\right] $.

\textbf{Проблема эквивалентности.} Дано два базиса $ \mathbf{B} $ и $ \mathbf{B}' $. Необходимо узнать, образуют ли они однинаковую решетку $ \mathcal{L}(\mathbf{B}) = \mathcal{L}(\mathbf{B}') $. Проблема решается путем вычисления $ \text{ЭНФ}(\mathbf{B}) $ и $ \text{ЭНФ}(\mathbf{B}') $ и сравнения их равенства:

$ \mathbf{B} = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $, 
$ \mathbf{B}' = \left[\begin{array}{cccc}
1 & 0 \\
1 & 1
\end{array}\right] $, 
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $,
$ \text{ЭНФ}(\mathbf{B}') = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $ -- образуют одинаковую решетку.

$ \mathbf{B} = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $, 
$ \mathbf{B}' = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $,
$ \text{ЭНФ}(\mathbf{B}') = \left[\begin{array}{cccc}
2 & 0 \\
0 & 1
\end{array}\right] $ -- не образуют одинаковой решетки.

\textbf{Объединение решеток.} Дано два базиса $ \mathbf{B} $ и $ \mathbf{B}' $. Необходимо найти базис для наименьшей решетки, содержащей обе решетки $ \mathcal{L}(\mathbf{B}) $ и $ \mathcal{L}(\mathbf{B}') $. Такая решетка будет сгенерирована от $ \left[\mathbf{B}|\mathbf{B}'\right] $, и можно легко найти ее базис через ЭНФ:

$ \mathbf{B} = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \mathbf{B}' = \left[\begin{array}{cccc}
0 & 1 \\
2 & 2
\end{array}\right] $, 
$ \left[\mathbf{B} | \mathbf{B}'\right] = \left[\begin{array}{cccc}
2 & 2 & 0 & 1 \\
1 & 0 & 2 & 2
\end{array}\right] $, 
$ \text{ЭНФ}(\left[\mathbf{B} | \mathbf{B}' \right]) = \left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0
\end{array}\right] $.

\textbf{Проблема включения.} Дано два базиса $ \mathbf{B} $ и $ \mathbf{B}' $. Необходимо узнать, является ли $ \mathcal{L}(\mathbf{B}') $ подрешеткой $ \mathcal{L}(\mathbf{B}) $, т.е. $ \mathcal{L}(\mathbf{B}') \subseteq \mathcal{L}(\mathbf{B}) $. Эта проблема сводится к проблемам объединения и эквивалентности: $ \mathcal{L}(\mathbf{B}') \subseteq \mathcal{L}(\mathbf{B}) $ тогда и только тогда, когда $ \mathcal{L}(\left[\mathbf{B}|\mathbf{B}'\right]) = \mathcal{L}(\mathbf{B}) $. Для этого необходимо вычислить $ \text{ЭНФ}(\left[\mathbf{B} | \mathbf{B}' \right]) $ и $ \text{ЭНФ}(\mathbf{B}) $ и сравнения их равенства:

$ \mathbf{B} = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \mathbf{B}' = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $, 
$ \left[\mathbf{B} | \mathbf{B}'\right] = \left[\begin{array}{cccc}
2 & 2 & 1 & 0 \\
1 & 0 & 0 & 1
\end{array}\right] $, 
$ \text{ЭНФ}(\left[\mathbf{B} | \mathbf{B}' \right]) = \left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0
\end{array}\right] $,
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
2 & 0 \\
0 & 1
\end{array}\right] $ -- $ \mathcal{L}(\mathbf{B}') $ не является подрешеткой $ \mathcal{L}(\mathbf{B}) $.

$ \mathbf{B} = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $, 
$ \mathbf{B}' = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \left[\mathbf{B} | \mathbf{B}'\right] = \left[\begin{array}{cccc}
1 & 0 & 2 & 2 \\
0 & 1 & 1 & 0
\end{array}\right] $, 
$ \text{ЭНФ}(\left[\mathbf{B} | \mathbf{B}' \right]) = \left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0
\end{array}\right] $,
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
1 & 0 \\
0 & 1
\end{array}\right] $ -- $ \mathcal{L}(\mathbf{B}') $ является подрешеткой $ \mathcal{L}(\mathbf{B}) $.

\textbf{Проблема содержания.} Дана решетка $ \mathbf{B} $ и вектор $ \mathbf{v} $, необходимо узнать, принадлежит ли вектор решетке ($ \mathbf{v} \subseteq \mathcal{L}(\mathbf{B}') $). Эта проблема сводится к проблеме включения путем проверки $ \mathcal{L}(\left[\mathbf{v}\right]) \subseteq \mathcal{L}(\mathbf{B}) $. Если необходимо проверить содержание нескольких векторов $ \mathbf{v}_1, \ldots, \mathbf{v}_n $, тогда следует сначала вычислить $ \mathbf{H} = \text{ЭНФ}(\mathbf{B}) $, и затем проверять, равно ли $ \mathbf{H} $ $ \text{ЭНФ}(\left[\mathbf{H} | \mathbf{v}_i \right]) $ для каждого вектора:

$ \mathbf{B} = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \mathbf{v} = \left[\begin{array}{cccc}
2 \\
0
\end{array}\right] $, 
$ \left[\mathbf{B} | \mathbf{B}'\right] = \left[\begin{array}{cccc}
2 & 2 & 2 \\
1 & 0 & 0
\end{array}\right] $, 
$ \text{ЭНФ}(\left[\mathbf{B} | \mathbf{v} \right]) = \left[\begin{array}{cccc}
2 & 0 & 0 \\
0 & 1 & 0
\end{array}\right] $,
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
2 & 0 \\
0 & 1
\end{array}\right] $ -- вектор $ \mathbf{v} \subseteq \mathcal{L}(\mathbf{B}) $.


$ \mathbf{B} = \left[\begin{array}{cccc}
2 & 2 \\
1 & 0
\end{array}\right] $, 
$ \mathbf{v} = \left[\begin{array}{cccc}
1 \\
0
\end{array}\right] $, 
$ \left[\mathbf{B} | \mathbf{B}'\right] = \left[\begin{array}{cccc}
2 & 2 & 1 \\
1 & 0 & 0
\end{array}\right] $, 
$ \text{ЭНФ}(\left[\mathbf{B} | \mathbf{v} \right]) = \left[\begin{array}{cccc}
1 & 0 & 0 \\
0 & 1 & 0
\end{array}\right] $,
$ \text{ЭНФ}(\mathbf{B}) = \left[\begin{array}{cccc}
2 & 0 \\
0 & 1
\end{array}\right] $ -- вектор $ \mathbf{v} \not \subseteq \mathcal{L}(\mathbf{B}) $.

\textbf{Решение систем линейных уравнений.} 


\clearpage